# OS

> Server | Cloud OS | PC | 嵌入式 <- 必要生存空间
>
> 系统性梳理整个技术体系： 在各种工作场合，深入挖掘！
>
> - 通信协议与网络安全
> - 

## 基础

- 磁盘管理与使用
  - 分区设置 ： fdisk -> 格式化：选择FS
  - 文件系统 - 虚拟
- 网络设置
  - NAT | 桥接
  - dhclient ,**动态主机配置协议**
  - 同一网段内，如何配置？
    - 网关 | host | 
    - 防火墙： iptables | firewalld
    - 
- 内存管理
  - /proc：内存映射
  - /sys：硬件驱动管理
  - /dev | /media | /mnt : 设备管理
  - /run: 进程Id
- 启动模式：OS自身修复
  - 

### 运行原理

> 计算机系统层次化 || 功能细分化：OS & 硬件设备知识储备
>
> - 用户态程序 & 三方库
> - 进程管理 | 进程调度 
> - 内存管理
> - 存储层次 | 文件系统
> - 外部存储器

#### 体系结构

- 用户模式-进程，内核模式-驱动程序，解决：os操纵设备的隔离性，以及通用性：中间层-驱动开发【精通各种设备】
- 内核：处于内核模式的程序，包括：进程管理，内存管理，进程调度..， OS包括
  - 用户模式下应用功能 + 系统调用
  - 内核
- 固件开发
  - BIOS | UEFI

#### 用户模式

> 系统调用 | OS 库 | 三方库 | 应用程序功能

- 系统调用封装函数: OS提供 封装的汇编语言 & 系统架构紧密关联
- OS标准库
  - C标准库： glibc  || POSIX : 基于Unix的os提供的功能
  - BSD标准库： FreeBSD - libc | NetBSD - libc
  - Windows API | .NET Framework
- OS提供的程序： init | systemctl | touch | sar | shell bash | X windows

#### 进程管理

> 虚拟内存

- fork -> 父进程复制内存
- execve -> 创建进程内存映像需要哪些信息？
  - 可执行文件结构： 程序 + 数据 || 程序开始运行所需的数据
  - 代码段 | 数据段 | 程序执行的第一条指令的内存地址
  - -> 详细解析ELF文件，对比exe文件
    - entry point address : 程序入口点
    - 代码段|数据段内存映像的起始地址，大小，偏移量

#### 进程调度

> 实现原理： 时间片
>
> 系统如何识别CPU: 进程|线程如何对应每一个逻辑CPU

- 时间片 - 轮询调度 ： 进程上下文切换
- 进程状态 - 事件
- 处理性能指标
  - 吞吐量 = 处理完成的进程数量 / 耗费时间 <- CPU算力决定上限！
  - 延迟 = 结束处理时间 - 开始处理时间 <- 调度 + 算力
  - **优化方向**：CPU始终处于运行状态，且无就绪状态的进程
    - CPU ideal-延迟 | 多进程-> 吞吐量
    - 监控指令
      - sar -p All 1 1 
      - time comm
- 多核处理器：taskset -c 0,1 comm
- 进程优先级： nice , **降低优先级无权限要求； 提高优先级必须root**
  - nice -n {-19:20} comm

#### 内存管理

- free 
  - avaiable = free + **内核可释放的内存**：缓冲区缓存，页面缓存中大部分内存，其他
  - total = avaiable + used + 内核不可释放的内存
- OOM killer: 选取可结束进进程
- **简单内存分配** 
  - 分配时机： 进程创建时分配 ； 进程运行中动态分配
  - 引起问题：
    - 内存碎片化 ： 不断重复执行创建于释放内存
    - 非法访问其他用途的内存区域：段异常 **缺页中断**
    - 难以执行多任务： elf等可执行文件格式决定：段偏移量等信息
- 【解决内存分配存在的问题】虚拟内存
  - 页表：实现虚拟地址到物理地址的映射
  - 页面：CPU架构设计，x86_64: 4KB
  - 请求分页
    - 页表： 进程独有， 【合理设计页表：实现连续虚拟地址空间，物理地址不用连续】
    - 虚拟地址空间： 每个进程独有。实现进程地址空间隔离
      - 内核的内存区域在 每个进程页表中均有一份映射 【内核模式标志】
      - 多进程：地址空间解决
- 虚拟内存使用场景
  - 文件映射： mmap(file) ,实现读取文件到内存 ， 然后做内存映射
    - 函数调用： mmap | memcpy
    - 问题：内存更新，什么时候写回外部存储器
    - 解决内存浪费问题 ： 请求分页，当且仅当在程序实际运行访问地址的时候，才进行物理地址分配与映射
      - 增加状态信息解决
        - 未分配虚拟地址空间
        - 已分配虚拟地址空间，
          - 未关联 -> 缺页中断，在首次访问
          - 已关联物理地址
    - 内存分配不足问题
      - 虚拟地址空间范围太小
        - X86: 4GB； X_64: 128TB
      - 物理内粗内存不足
  - 写时复制 ： 延迟操作物理内存！
    - 解决： 提高fork()的执行速度 ， 考虑大多数程序不会运行所有的代码段！
    - 流程
      1. 子进程只复制父进程页表 ， 此时只有读取权限， 父子均无写入权限
      2. 父子人一个更改数据， **解除共享**
         1. 无写入权限：从而引发 缺页中断
         2. CPU转入内核模式，缺页中断机制运行：
            1. 被访问页面，复制一份提供 需要更新数据一方； 并 更新对应页表
            2. 赋予双方对该页表的写入权限
    - swap : OOM物理内存耗尽
      - swap分区：页表信息更新 - swap out部分信息
        - 怎么决定swap out的区域
        - 频繁的swap in|out -> 系统性能抖动
      - 监测指令： sar -W 1 || sar -S 1 : 查看kbswpused
      - 是否涉及外部存储器：硬性页缺失， 软性页缺失
  - 多级页表: 内存大小**4GB - 32GB**
    - 计算页表占用空间 = 虚拟地址空间大小 / 页面大小 * 页表项大小
    - 单极页表：占用空间过大：如x86_64: 128TB , 4KB , 8B = 256GB || X86: 4GB/4KB*8B = 8KB
  - 标准大页： 降低页表占用空间，直接影响：fork()速度变慢
    - 常见案例： 数据库， 虚拟机管理等支持：开启使用标准大页的设置
    - 透明大页机制： 虚拟内存出现多个连续4KB页面进行合并，以及大页拆分问题

#### 存储层次

> 容量， 价格，访问速度

- 寄存器 - 高速缓存 - 内存 - 外部存储器
  - 缓存块： 缓存行为单位进行读写，支持：write-back | write-through ； 【脏标志】
  - 缓存不足 -> 多级缓存

![image-20231027230620336](D:\tech_stacks\mk-2023-os-architecture-cpu\CPU cache level)

- TLB: translation lookaside buffer : 解决访问物理内存的页表速度慢的问题，缓存：页表数据
- 页面缓存：缓存外部存储器的文件数据 ； 访问单位：页 ； 位置：内核内存
  - 访问文件数据：涉及两次数据复制，1 复制到内核内存的页面缓存 2 从缓存复制到进程内存
  - 所有进程共享读取； 写入：先写入页面缓存，标记：脏数据， 内核在一定时间写回文件
  - 系统可用内存不足，如OOM:会释放页面缓存中非脏数据空间； 同理：可用内存充足，页面缓存会随进程并发|增多而增加
  - 系统性能抖动：本质负载过高，比如：大量脏页数据的回写操作，以及进程调度开销增大等
  - 同步写入，异步写入机制
- 缓冲区缓存：跳过 文件系统， 设备文件直接访问外部存储器时使用的区域， 如：mmap，网卡与内存跳过CPU
  - 

#### 文件系统

> 降低用户：写入文件，管理外部存储器容量的复杂度，包括文件名称，位置，大小等繁杂信息

- 类型
  - 【外部存储设备】Linux支持：ext4, XFS, Btrfs...
  - 基于内存： tmpfs
  - 网络文件系统： win:cifs ，Linux:nfs
  - 虚拟文件系统： 
    - procfs: CPU信息， 挂载 /proc/pid/** ; 以及/proc/**: 包含cpu,disk,mem,内核调优参数
    - sysfs: 系统上设备， 各种文件系统
    - **cgroups**: 限制单进程|多进程群组的资源使用量，常见于： docker,等虚拟机管理容器，虚拟机的资源使用量
  - Btrfs
    - 区别于ext4|XFS每个分区一个fs, Btrfs可创建一个包含多个外部存储器|分区的存储池，**子卷**
    - 快照 &  复制
      - 快照一份数据，多份元数据 ： 出现脏数据，回写
      - 复制：数据，元数据均复制一份
    - RAID级别
      - RAID 0 | 1 | 5,6,10
      - 数据损坏的检测与恢复 - 文件校验和
        - FS 系统是否支持：检测，丢弃|修复功能
- 设计原理
  - 目录 -> 树状结构 ; 
  - 统一系统调用访问接口
  - 数据与元数据：种类，时间信息，权限信息 【文件名称，大小，外部存储器位置】
  - 容量限制：quota磁盘配额 -> （ext4,XFS）用户配额，目录配额， (Btrfs)【子卷配额】 
- 工作流程
  - 文件系统通用处理 -> 定位 操作对象对应哪个文件系统
  - 文件系统专有处理 【对应系统调用的处理】
  - 读写数据：设备驱动程序执行读写操作
- 问题：
  - 文件系统数据不一致问题：非原子操作导致，如文件操作中断点
    - 解决方案： 日志(ext4 , XFS) ， 写时复制(Btrfs) 等技术
  - 日志
    - 如果日志写入失败，相当于：undo, 保持原状
    - 如果执行日志更新文件失败，相当于：redo,按照日志重新执行，最终结果一致
  - 写时复制
    - 更新数据到另一个位置，删除旧链接
  - 日常维护
    - 【推荐】定期备份
    - 【0】fsck恢复命令：将数据不一致的文件系统 强行改变到 可以挂载的状态 【一切不一致的数据与元数据均被强制删除】
- 设备文件
  - 字符设备
    - 键盘，鼠标，显示器
  - 块设备
    - HDD, SSD
    - 访问场景
      - 在设备上创建文件系统，挂载文件系统，通过文件系统访问
      - 其他直接操作设备：
        - parted 更新分区表
        - dd 块设备级别的数据备份与还原
        - mkfs 创建文件系统
        - mount 挂载文件系统
        - fsck

#### 外部存储器

> HDD -> SSD

##### HDD

- 读写单位：扇区， 磁性信息-数据，记录在盘片 【磁盘】
- 读写流程
  - 【电子操作】设备驱动程序： 读写数据需要的信息，包括 扇区序列号，扇区数量，访问类型等 传给：HDD
  - 【机械操作】HDD操作磁头摆臂，转动盘片
  - 【电子操作】执行读写操作
- 性能问题
  - 一次访问请求：读取多个连续扇区数据 ， **HDD单次访问获取数据量的极限值可测量**
  - 不连续扇区：则需要多次提交访问请求
  - 实践：
    1. 尽可能 将文件数据存放在连续扇区，或相近区域； 
    2. 经连续区域的访问请求汇总到一次访问请求中
    3. 对于文件：尽量以顺序访问的方式访问 尽可能大的数据量
- 通用块层： 屏蔽各中块设备的差异
  - **I/O调度器** -> 区别 进程调度器的设计思想
    - 合并：多个访问连续扇区的I/O请求
    - 排序：按照扇区序列号对访问不连续的多个I/O请求进行排序
  - 预读 -> 实现： 内核开启I/O支援功能
  - iostat -x -p fd 1 : rrqm/s | wrqm/s 合并读写请求

##### SSD





## 实践

> 固件开发
>
> - BIOS | UEFI



### makefile

> so动态链接库,如glibc 

- 



### Linux驱动开发



### 固件开发



### 虚拟化



# 入局

> 行业领军人物的思想 ， 看到自身的规划路线





## QA

- [1] /boot200M ； swap:内存2倍； /剩余数据空间

- [0] glibc 库熟悉，常见：unistd.h / stdio.h / stdlib.h / err.h ...

  - **/usr/include/* : 相关资料介绍**

- 【0】 进程状态切换完整流程

  ![image-20231027160748984](D:\tech_stacks\mk-2023-os-architecture-cpu\进程状态)

  - 进程状态
    - R | S 或 D ：睡眠态，区别：S可通过接收信号回到R ,其他D | Z 
  - 状态切换事件
    - 睡眠态进程等待事件有：等待指定时间 | 等待输入输出设备，键盘鼠标 | 等待外部存储设备读写结束 | 等待网卡收发结束
    - D:毫秒状态迁移，否则： 存储器IO 或其他内核问题
  - 逻辑CPU - 如何进入空闲状态： CPU休眠，具体表现：待机
    - 无任何就绪状态进程时，如何实现？

- 【0】蓝牙失效问题 - 信号丢失？

  - 蓝牙鼠标，键盘无响应如何解决
  - 蓝牙耳机呢？

- 【0】内核如何销毁高速缓存？

- 【0】操作系统有哪些跳过FS , CPU等直接交互的案例

  - Direct IO | Mmap | 原始设备访问：主要做数据恢复等低级别访问
  - 问题：缓冲区缓存与页面缓存的区别？ 如何实现跳过FS
    - 页面缓存：优化文件写入的性能 || 缓冲区缓存：文件读取
    - systemctl vm.dirty.*优化脏读数据： 回写时机：dirty_backgroup_ratio; 进一步阻塞进程：dirty_ratio

- [0] 超线程开启

- 【0】VPN搭建

  - 对网络服务进一步实践与认识：包括，DNS,...搭建

- 【0】LVM & 文件系统？

- 【0】**I/O调度器** -> 区别 进程调度器的设计思想

  - 

- 高性能网络设备有哪些

- sar指令大全

  - sar -d -p 1：外部存储器的IO吞吐量
  - sar -r 1 : free相关
  - sar -B 1 : swapin, swapout，中断信息
  - sar -P ALL 1: CPU信息
